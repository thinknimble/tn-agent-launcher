name: 'Generate Terraform Variables'
description: 'Generates terraform.tfvars file with environment-specific configuration'

inputs:
  environment:
    description: 'Environment name'
    required: true
  mode:
    description: 'Mode: deploy, cleanup, or teardown'
    required: false
    default: 'deploy'

outputs:
  debug:
    description: 'Debug mode setting'
    value: ${{ steps.app-config.outputs.debug }}
  current_port:
    description: 'Current port setting'
    value: ${{ steps.app-config.outputs.current_port }}
  allowed_hosts:
    description: 'Allowed hosts setting'
    value: ${{ steps.app-config.outputs.allowed_hosts }}
  enable_emails:
    description: 'Enable emails setting'
    value: ${{ steps.app-config.outputs.enable_emails }}
  staff_email:
    description: 'Staff email setting'
    value: ${{ steps.app-config.outputs.staff_email }}
  use_aws_storage:
    description: 'Use AWS storage setting'
    value: ${{ steps.app-config.outputs.use_aws_storage }}
  aws_s3_region_name:
    description: 'AWS S3 region name'
    value: ${{ steps.app-config.outputs.aws_s3_region_name }}
  enable_https:
    description: 'Enable HTTPS setting'
    value: ${{ steps.app-config.outputs.enable_https }}
  django_secret_key:
    description: 'Django secret key'
    value: ${{ steps.secrets.outputs.django_secret_key }}
  field_encryption_key:
    description: 'Field encryption key'
    value: ${{ steps.secrets.outputs.field_encryption_key }}
  db_password:
    description: 'Database password'
    value: ${{ steps.secrets.outputs.db_password }}
  django_superuser_password:
    description: 'Django superuser password'
    value: ${{ steps.secrets.outputs.django_superuser_password }}
  rollbar_access_token:
    description: 'Rollbar access token'
    value: ${{ steps.secrets.outputs.rollbar_access_token }}
  aws_access_key_id:
    description: 'AWS access key ID'
    value: ${{ steps.secrets.outputs.aws_access_key_id }}
  aws_secret_access_key:
    description: 'AWS secret access key'
    value: ${{ steps.secrets.outputs.aws_secret_access_key }}
  playwright_test_user_pass:
    description: 'Playwright test user password'
    value: ${{ steps.secrets.outputs.playwright_test_user_pass }}

runs:
  using: 'composite'
  steps:
    - name: Load app configuration
      id: app-config
      shell: bash
      run: |
        echo "ðŸ” Looking up app configuration for environment: ${{ inputs.environment }}"
        
        # Create get-app-config.sh if it doesn't exist
        if [[ ! -f "get-app-config.sh" ]]; then
          cat > get-app-config.sh << 'EOF'
        #!/bin/bash
        ENV_NAME="$1"
        
        # Check if environments.json exists
        if [[ -f "environments.json" ]]; then
          CONFIG_FILE="environments.json"
        elif [[ -f ".github/environments.json" ]]; then
          CONFIG_FILE=".github/environments.json"
        else
          echo "ERROR: No environments.json found"
          exit 1
        fi
        
        # Get configuration for environment
        CONFIG=$(jq -r --arg env "$ENV_NAME" '.environments[$env] // empty' "$CONFIG_FILE")
        
        if [[ -z "$CONFIG" || "$CONFIG" == "null" ]]; then
          echo "ERROR: No configuration found for environment: $ENV_NAME"
          exit 1
        fi
        
        echo "$CONFIG"
        EOF
          chmod +x get-app-config.sh
        fi
        
        APP_CONFIG_OUTPUT=$(./get-app-config.sh "${{ inputs.environment }}")
        
        if [[ $? -ne 0 ]]; then
          echo "âŒ Failed to load app configuration"
          echo "$APP_CONFIG_OUTPUT"
          exit 1
        fi
        
        echo "app_config<<EOF" >> $GITHUB_OUTPUT
        echo "$APP_CONFIG_OUTPUT" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Extract individual app config values and set as outputs
        echo "debug=$(echo "$APP_CONFIG_OUTPUT" | grep "^debug=" | cut -d= -f2)" >> $GITHUB_OUTPUT
        echo "current_port=$(echo "$APP_CONFIG_OUTPUT" | grep "^current_port=" | cut -d= -f2)" >> $GITHUB_OUTPUT
        echo "allowed_hosts=$(echo "$APP_CONFIG_OUTPUT" | grep "^allowed_hosts=" | cut -d= -f2)" >> $GITHUB_OUTPUT
        echo "enable_emails=$(echo "$APP_CONFIG_OUTPUT" | grep "^enable_emails=" | cut -d= -f2)" >> $GITHUB_OUTPUT
        echo "staff_email=$(echo "$APP_CONFIG_OUTPUT" | grep "^staff_email=" | cut -d= -f2)" >> $GITHUB_OUTPUT
        echo "use_aws_storage=$(echo "$APP_CONFIG_OUTPUT" | grep "^use_aws_storage=" | cut -d= -f2)" >> $GITHUB_OUTPUT
        echo "aws_s3_region_name=$(echo "$APP_CONFIG_OUTPUT" | grep "^aws_s3_region_name=" | cut -d= -f2)" >> $GITHUB_OUTPUT
        echo "enable_https=$(echo "$APP_CONFIG_OUTPUT" | grep "^enable_https=" | cut -d= -f2)" >> $GITHUB_OUTPUT
        
        echo "âœ… App configuration loaded for environment '${{ inputs.environment }}'"

    - name: Load Secrets and Generate terraform.tfvars  
      id: secrets
      shell: bash
      run: |
        cd terraform
        
        ENVIRONMENT="${{ inputs.environment }}"
        
        echo "ðŸ” Retrieving secrets for environment: $ENVIRONMENT"
        
        if [[ "${{ inputs.mode }}" == "deploy" ]]; then
          # Use existing secrets-sync script which has fallback logic for PRs
          if .github/scripts/secrets-sync.sh pull "$ENVIRONMENT" --file secrets.json; then
            echo "âœ… Secrets retrieved successfully"
            
            # Validate secrets.json contains valid JSON
            if ! jq empty secrets.json 2>/dev/null; then
              echo "âŒ Retrieved secrets file is not valid JSON"
              exit 1
            fi
            
            # Extract secrets and set as outputs (matching original workflow)
            echo "django_secret_key=$(jq -r '.secrets.django_secret_key' secrets.json)" >> $GITHUB_OUTPUT
            echo "field_encryption_key=$(jq -r '.secrets.field_encryption_key' secrets.json)" >> $GITHUB_OUTPUT
            echo "db_password=$(jq -r '.secrets.db_password' secrets.json)" >> $GITHUB_OUTPUT
            echo "django_superuser_password=$(jq -r '.secrets.django_superuser_password' secrets.json)" >> $GITHUB_OUTPUT
            echo "rollbar_access_token=$(jq -r '.secrets.rollbar_access_token // ""' secrets.json)" >> $GITHUB_OUTPUT
            echo "aws_access_key_id=$(jq -r '.secrets.aws_access_key_id // ""' secrets.json)" >> $GITHUB_OUTPUT
            echo "aws_secret_access_key=$(jq -r '.secrets.aws_secret_access_key // ""' secrets.json)" >> $GITHUB_OUTPUT
            echo "playwright_test_user_pass=$(jq -r '.secrets.playwright_test_user_pass' secrets.json)" >> $GITHUB_OUTPUT
            
            echo "âœ… Secrets loaded and available as step outputs"
          else
            echo "âš ï¸  Failed to retrieve secrets from bucket"
            echo "ðŸ’¡ Check secrets configuration for environment: $ENVIRONMENT"
          fi
        fi
        
        echo "ðŸ”§ Generating terraform.tfvars for environment: $ENVIRONMENT"
        
        # Parse domain from app config
        DOMAIN_NAME=$(echo '${{ steps.app-config.outputs.app_config }}' | jq -r '.domain_name // "localhost"')
        CERTIFICATE_ARN=$(echo '${{ steps.app-config.outputs.app_config }}' | jq -r '.certificate_arn // ""')
        HOSTED_ZONE_ID=$(echo '${{ steps.app-config.outputs.app_config }}' | jq -r '.hosted_zone_id // ""')
        
        cat > terraform.tfvars << EOF
        # Environment Configuration
        environment = "$ENVIRONMENT"
        
        # Database Configuration  
        db_name = "$(echo 'tn-agent-launcher${ENVIRONMENT}db' | tr -d '-')"
        db_user = "tn-agent-launcher_${ENVIRONMENT}_user"
        
        # Domain and Route53 configuration from environments.json
        domain_name = "$DOMAIN_NAME"
        certificate_arn = "$CERTIFICATE_ARN"
        hosted_zone_id = "$HOSTED_ZONE_ID"
        EOF
        
        echo "âœ… Generated terraform.tfvars and set environment variables for: $ENVIRONMENT"